{"version":3,"file":"index.min.js","sources":["../src/base.ts","../src/challenge.ts","../src/client.ts","../src/refreshToken.ts","../src/state.ts","../src/token.ts","../src/bridge/CookieUniversal.ts","../src/init.ts","../src/bridge/StorageLocalForage.ts"],"sourcesContent":["import {\n  CookieGetOptions,\n  CookieSetOptions, Data,\n  StorageInterface,\n  TokenConfig,\n} from './interfaces';\n\nexport default abstract class Base {\n  protected defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n  };\n\n  public config: TokenConfig;\n\n  protected constructor(\n    protected storage: StorageInterface,\n    // eslint-disable-next-line no-empty-function\n  ) {\n\n  }\n\n  public get<T = Data>(options?: CookieGetOptions): Promise<T> {\n    return this.storage.get<T>(this.getName(), options);\n  }\n\n  public remove(options?: CookieSetOptions): void {\n    this.storage.remove(this.getName(), options);\n  }\n\n  public set<T>(value: T, options?: CookieSetOptions): Promise<T> {\n    return this.storage.set<T>(this.getName(), value, options);\n  }\n\n  public setConfig(defaultConfig: TokenConfig, config?: TokenConfig) {\n    if (config) {\n      this.config = { ...defaultConfig, ...config };\n      return;\n    }\n    this.config = { ...defaultConfig };\n  }\n\n  public getName(): string {\n    const { prefix, name } = this.config;\n\n    if (!prefix) {\n      return name;\n    }\n\n    return `${prefix}${name}`;\n  }\n}\n","import forge from 'node-forge';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport Base from './base';\nimport {\n  BaseInterface,\n  StorageInterface, TokenConfig,\n} from './interfaces';\n\nexport default class Challenge extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'challenge',\n  };\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n\n  public generate(): Promise<string> {\n    let challenge = `${(uuidv4() as string)}${(uuidv4() as string)}${(uuidv4() as string)}`;\n    challenge = challenge.replaceAll('-', '');\n\n    const md = forge.md.sha256.create();\n    md.update(challenge);\n    // noinspection UnnecessaryLocalVariableJS\n    const code = forge.util.encode64(md.digest().data);\n\n    const hash = code.replaceAll('+', '-')\n      .replaceAll('/', '_')\n      .replace(/=$/, '');\n\n    this.set(challenge);\n\n    return Promise.resolve(hash);\n  }\n}\n","import { v4 as uuidv4 } from 'uuid';\n\nimport Challenge from './challenge';\nimport {\n  DataInterface,\n  OAuthConfigInterface,\n} from './interfaces';\nimport State from './state';\n\nexport default class Client {\n  constructor(private config: OAuthConfigInterface,\n              private challenge: Challenge,\n              private state: State) { // eslint-disable-next-line no-empty-function\n  }\n\n  public getConfig(key?: string): string | OAuthConfigInterface {\n    if (key) {\n      return this.config[key];\n    }\n\n    return this.config;\n  }\n\n  public authorize(scope: string): void {\n    if (!window) {\n      throw new Error('Oauth service can only be run client side.');\n    }\n    const state = uuidv4().replaceAll('-', '');\n\n    Promise.all([\n      this.challenge.generate(),\n      this.state.set(state)]).then(([challenge]) => {\n      const { client_id, authenticateUri } = this.config;\n\n      const params = {\n        state,\n        client_id,\n        scope,\n        redirect_uri: this.getRedirectUri(),\n        response_type: 'code',\n        code_challenge: challenge,\n        code_challenge_method: 'S256',\n      };\n\n      const searchParams = new URLSearchParams(params as any);\n      window.location.href = `${authenticateUri as string}?${searchParams.toString()}`;\n    });\n  }\n\n  public async getRequestTokenData(state: string, code: string): Promise<DataInterface> {\n    const localState = await this.state.get();\n    const challenge = await this.challenge.get();\n\n    if (localState !== state) {\n      throw new Error('State do not match');\n    }\n\n    const { client_id, tokenUri } = this.config;\n\n    return {\n      uri: tokenUri,\n      data: {\n        code,\n        client_id,\n        code_verifier: challenge,\n        redirect_uri: this.getRedirectUri(),\n        grant_type: 'authorization_code',\n      },\n    };\n  }\n\n  public getRefreshTokenData(scope: string, token: string) {\n    const { client_id, tokenUri } = this.config;\n    return {\n      uri: tokenUri,\n      data: {\n        client_id,\n        scope,\n        refresh_token: token,\n        grant_type: 'refresh_token',\n      },\n    };\n  }\n\n  private getRedirectUri() {\n    const { redirectUri } = this.config;\n    const { location: { protocol, hostname, port } } = window;\n    let rUri = `${protocol}://${hostname}${redirectUri}`;\n    if ((protocol === 'https:' && port !== '443') || (protocol === 'http:' && port !== '80')) {\n      rUri = `${protocol}//${hostname}:${port}${redirectUri}`;\n    }\n\n    return rUri;\n  }\n}\n","import Base from './base';\nimport {\n  BaseInterface,\n  StorageInterface, TokenConfig,\n} from './interfaces';\n\nexport default class RefreshToken extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'refresh_token',\n  };\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n}\n","import Base from './base';\nimport {\n  BaseInterface, StorageInterface,\n  TokenConfig,\n} from './interfaces';\n\nexport default class State extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'state',\n  };\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n}\n","import jwt_decode from 'jwt-decode';\n\nimport Base from './base';\nimport {\n  BaseInterface,\n  CookieGetOptions,\n  CookieSetOptions, Data,\n  ParseTokenInterface,\n  StorageInterface, TokenConfig,\n} from './interfaces';\n\nexport default class Token extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'token',\n  };\n\n  private parsed: ParseTokenInterface;\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n\n  public set<T = Data>(value: T, options?: CookieSetOptions): Promise<T> {\n    if (typeof value === 'string') {\n      this.parseToken(value);\n    }\n    return this.storage.set<T>(this.getName(), value, options);\n  }\n\n  private parseToken(token: string): void {\n    this.parsed = jwt_decode(token);\n  }\n\n  public getParsed(): any {\n    return this.parsed;\n  }\n\n  public isLoaded(): boolean {\n    return !!this.parsed;\n  }\n\n  public isExpired(): boolean {\n    if (!this.parsed) {\n      return false;\n    }\n\n    const date = new Date();\n    return date.getTime() <= this.parsed.exp;\n  }\n\n  public guard(scope?: string | string[]): boolean {\n    if (!this.parsed) {\n      return false;\n    }\n\n    if (typeof scope === 'undefined') {\n      return true;\n    }\n\n    const scopes = Array.isArray(scope) ? scope : [scope];\n    const filtered = scopes.filter((item: string) => !this.parsed.scopes.includes(item));\n    return filtered.length <= 0;\n  }\n\n  public async loadToken(options?: CookieGetOptions): Promise<boolean> {\n    const token = await this.get(options);\n\n    if (!token || typeof token !== 'string') {\n      return false;\n    }\n\n    this.parseToken(token);\n\n    if (this.isExpired()) {\n      this.remove();\n      return false;\n    }\n\n    return true;\n  }\n}\n","import Cookies from 'universal-cookie';\n\nimport {\n  CookieGetOptions,\n  CookieSetOptions,\n  Data,\n  StorageInterface,\n} from '../interfaces';\n\nexport default class CookieUniversal implements StorageInterface {\n  // eslint-disable-next-line no-empty-function\n  constructor(private instance: Cookies) {\n  }\n\n  public set<T = Data>(name: string, value: T, options?: CookieSetOptions): Promise<T> {\n    this.instance.set(name, value, { path: '/', ...options });\n\n    return Promise.resolve<T>(value);\n  }\n\n  public async get<T = Data>(name: string, options?: CookieGetOptions): Promise<T> {\n    return Promise.resolve(this.instance.get(name, options));\n  }\n\n  public async remove(name: string, options?: CookieSetOptions): Promise<void> {\n    await this.instance.remove(name, { path: '/', ...options });\n  }\n}\n","import Challenge from './challenge';\nimport Client from './client';\nimport {\n  InitOptionsInterface,\n  OAuthConfigInterface,\n  StorageInterface,\n} from './interfaces';\nimport RefreshToken from './refreshToken';\nimport State from './state';\nimport Token from './token';\n\nexport default class Init {\n  private readonly token: Token;\n\n  private readonly refreshToken: RefreshToken;\n\n  private readonly challenge: Challenge;\n\n  private readonly state: State;\n\n  private readonly client: Client;\n\n  public constructor(\n    private oAuthConfig: OAuthConfigInterface,\n    private storage: StorageInterface,\n    private options: InitOptionsInterface,\n  ) {\n    this.token = new Token(options?.token?.storage || storage, options?.token);\n    this.refreshToken = new RefreshToken(options?.refreshToken?.storage || storage, options?.refreshToken);\n    this.challenge = new Challenge(options?.challenge?.storage || storage, options?.challenge);\n    this.state = new State(options?.state?.storage || storage, options?.state);\n\n    this.client = new Client(this.oAuthConfig, this.challenge, this.state);\n  }\n\n  public getToken(): Token {\n    return this.token;\n  }\n\n  public getRefreshToken(): RefreshToken {\n    return this.refreshToken;\n  }\n\n  public getChallenge(): Challenge {\n    return this.challenge;\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public getClient(): Client {\n    return this.client;\n  }\n}\n","import * as LocalForage from 'localforage';\n\nimport {\n  CookieGetOptions,\n  CookieSetOptions,\n  Data,\n  StorageInterface,\n} from '../interfaces';\n\nexport default class StorageLocalForage implements StorageInterface {\n  // eslint-disable-next-line no-empty-function\n  constructor(private instance: LocalForage) {\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public set<T = Data>(name: string, value: T, _options?: CookieSetOptions): Promise<T> {\n    return this.instance.setItem<T>(name, value);\n  }\n\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public async get<T = Data>(name: string, _options?: CookieGetOptions): Promise<T> {\n    // eslint-disable-next-line no-return-await\n    return await this.instance.getItem<T>(name);\n  }\n\n  public async remove(name: string): Promise<void> {\n    await this.instance.removeItem(name);\n  }\n}\n"],"names":["Base","constructor","storage","this","prefix","get","options","getName","remove","set","value","setConfig","defaultConfig","config","name","Challenge","super","generate","challenge","uuidv4","replaceAll","md","forge","sha256","create","update","hash","util","encode64","digest","data","replace","Promise","resolve","Client","state","getConfig","key","authorize","scope","window","Error","all","then","client_id","authenticateUri","params","redirect_uri","getRedirectUri","response_type","code_challenge","code_challenge_method","searchParams","URLSearchParams","location","href","toString","getRequestTokenData","code","localState","tokenUri","uri","code_verifier","grant_type","getRefreshTokenData","token","refresh_token","redirectUri","protocol","hostname","port","rUri","RefreshToken","State","Token","parseToken","parsed","jwt_decode","getParsed","isLoaded","isExpired","Date","getTime","exp","guard","Array","isArray","filter","item","scopes","includes","length","loadToken","instance","path","oAuthConfig","refreshToken","client","getToken","getRefreshToken","getChallenge","getState","getClient","_options","setItem","getItem","removeItem"],"mappings":"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"}