{"version":3,"file":"index.min.js","sources":["../src/base.ts","../src/challenge.ts","../src/client.ts","../src/bridge/CookieUniversal.ts","../src/refreshToken.ts","../src/state.ts","../src/bridge/StorageLocalForage.ts","../src/token.ts"],"sourcesContent":["import {\n  CookieGetOptions,\n  CookieSetOptions, Data,\n  StorageInterface,\n  TokenConfig,\n} from './interfaces';\n\nexport default abstract class Base {\n  protected defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n  };\n\n  public config: TokenConfig;\n\n  protected constructor(\n    protected storage: StorageInterface,\n    // eslint-disable-next-line no-empty-function\n  ) {\n\n  }\n\n  public get<T = Data>(options?: CookieGetOptions): Promise<T> {\n    return this.storage.get<T>(this.getName(), options);\n  }\n\n  public remove(options?: CookieSetOptions): void {\n    this.storage.remove(this.getName(), options);\n  }\n\n  public set<T>(value: T, options?: CookieSetOptions): Promise<T> {\n    return this.storage.set<T>(this.getName(), value, options);\n  }\n\n  public setConfig(defaultConfig: TokenConfig, config?: TokenConfig) {\n    if (config) {\n      this.config = { ...defaultConfig, ...config };\n      return;\n    }\n    this.config = { ...defaultConfig };\n  }\n\n  public getName(): string {\n    const { prefix, name } = this.config;\n\n    if (!prefix) {\n      return name;\n    }\n\n    return `${prefix}${name}`;\n  }\n}\n","import forge from 'node-forge';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport Base from './base';\nimport {\n  BaseInterface,\n  StorageInterface, TokenConfig,\n} from './interfaces';\n\nexport default class Challenge extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'challenge',\n  };\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n\n  public generate(): Promise<string> {\n    let challenge = `${(uuidv4() as string)}${(uuidv4() as string)}${(uuidv4() as string)}`;\n    challenge = challenge.replaceAll('-', '');\n\n    const md = forge.md.sha256.create();\n    md.update(challenge);\n    // noinspection UnnecessaryLocalVariableJS\n    const code = forge.util.encode64(md.digest().data);\n\n    const hash = code.replaceAll('+', '-')\n      .replaceAll('/', '_')\n      .replace(/=$/, '');\n\n    this.set(challenge);\n\n    return Promise.resolve(hash);\n  }\n}\n","import { v4 as uuidv4 } from 'uuid';\n\nimport Challenge from './challenge';\nimport {\n  DataInterface,\n  OAuthConfigInterface,\n} from './interfaces';\nimport State from './state';\n\nexport default class Client {\n  constructor(private config: OAuthConfigInterface,\n              private challenge: Challenge,\n              private state: State) { // eslint-disable-next-line no-empty-function\n  }\n\n  public getConfig(key?: string): string | OAuthConfigInterface {\n    if (key) {\n      return this.config[key];\n    }\n\n    return this.config;\n  }\n\n  public authorize(scope: string): void {\n    if (!window) {\n      throw new Error('Oauth service can only be run client side.');\n    }\n    const state = uuidv4().replaceAll('-', '');\n\n    Promise.all([\n      this.challenge.generate(),\n      this.state.set(state)]).then(([challenge]) => {\n      const { client_id, authenticateUri } = this.config;\n\n      const params = {\n        state,\n        client_id,\n        scope,\n        redirect_uri: this.getRedirectUri(),\n        response_type: 'code',\n        code_challenge: challenge,\n        code_challenge_method: 'S256',\n      };\n\n      const searchParams = new URLSearchParams(params as any);\n      window.location.href = `${authenticateUri as string}?${searchParams.toString()}`;\n    });\n  }\n\n  public async getRequestTokenData(state: string, code: string): Promise<DataInterface> {\n    const localState = await this.state.get();\n    const challenge = await this.challenge.get();\n\n    if (localState !== state) {\n      throw new Error('State do not match');\n    }\n\n    const { client_id, tokenUri } = this.config;\n\n    return {\n      uri: tokenUri,\n      data: {\n        code,\n        client_id,\n        code_verifier: challenge,\n        redirect_uri: this.getRedirectUri(),\n        grant_type: 'authorization_code',\n      },\n    };\n  }\n\n  public getRefreshTokenData(scope: string, token: string) {\n    const { client_id, tokenUri } = this.config;\n    return {\n      uri: tokenUri,\n      data: {\n        client_id,\n        scope,\n        refresh_token: token,\n        grant_type: 'refresh_token',\n      },\n    };\n  }\n\n  private getRedirectUri() {\n    const { redirectUri } = this.config;\n    const { location: { protocol, hostname, port } } = window;\n    let rUri = `${protocol}://${hostname}${redirectUri}`;\n    if ((protocol === 'https:' && port !== '443') || (protocol === 'http:' && port !== '80')) {\n      rUri = `${protocol}//${hostname}:${port}${redirectUri}`;\n    }\n\n    return rUri;\n  }\n}\n","import Cookies from 'universal-cookie';\n\nimport {\n  CookieGetOptions,\n  CookieSetOptions,\n  Data,\n  StorageInterface,\n} from '../interfaces';\n\nexport default class CookieUniversal implements StorageInterface {\n  // eslint-disable-next-line no-empty-function\n  constructor(private instance: Cookies) {\n  }\n\n  public set<T = Data>(name: string, value: T, options?: CookieSetOptions): Promise<T> {\n    this.instance.set(name, value, { path: '/', ...options });\n\n    return Promise.resolve<T>(value);\n  }\n\n  public async get<T = Data>(name: string, options?: CookieGetOptions): Promise<T> {\n    return Promise.resolve(this.instance.get(name, options));\n  }\n\n  public async remove(name: string, options?: CookieSetOptions): Promise<void> {\n    await this.instance.remove(name, { path: '/', ...options });\n  }\n}\n","import Base from './base';\nimport {\n  BaseInterface,\n  StorageInterface, TokenConfig,\n} from './interfaces';\n\nexport default class RefreshToken extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'refresh_token',\n  };\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n}\n","import Base from './base';\nimport {\n  BaseInterface, StorageInterface,\n  TokenConfig,\n} from './interfaces';\n\nexport default class State extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'state',\n  };\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n}\n","import * as LocalForage from 'localforage';\n\nimport {\n  CookieGetOptions,\n  CookieSetOptions,\n  Data,\n  StorageInterface,\n} from '../interfaces';\n\nexport default class StorageLocalForage implements StorageInterface {\n  // eslint-disable-next-line no-empty-function\n  constructor(private instance: LocalForage) {\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public set<T = Data>(name: string, value: T, _options?: CookieSetOptions): Promise<T> {\n    return this.instance.setItem<T>(name, value);\n  }\n\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public async get<T = Data>(name: string, _options?: CookieGetOptions): Promise<T> {\n    // eslint-disable-next-line no-return-await\n    return await this.instance.getItem<T>(name);\n  }\n\n  public async remove(name: string): Promise<void> {\n    await this.instance.removeItem(name);\n  }\n}\n","import jwt_decode from 'jwt-decode';\n\nimport Base from './base';\nimport {\n  BaseInterface,\n  CookieGetOptions,\n  CookieSetOptions, Data,\n  ParseTokenInterface,\n  StorageInterface, TokenConfig,\n} from './interfaces';\n\nexport default class Token extends Base implements BaseInterface {\n  public defaultConfig: TokenConfig = {\n    prefix: 'oauth_',\n    name: 'token',\n  };\n\n  private parsed: ParseTokenInterface;\n\n  constructor(protected storage: StorageInterface, config?: TokenConfig) {\n    super(storage);\n\n    this.setConfig(this.defaultConfig, config);\n  }\n\n  public set<T = Data>(value: T, options?: CookieSetOptions): Promise<T> {\n    if (typeof value === 'string') {\n      this.parseToken(value);\n    }\n    return this.storage.set<T>(this.getName(), value, options);\n  }\n\n  private parseToken(token: string): void {\n    this.parsed = jwt_decode(token);\n  }\n\n  public getParsed(): any {\n    return this.parsed;\n  }\n\n  public isLoaded(): boolean {\n    return !!this.parsed;\n  }\n\n  public isExpired(): boolean {\n    if (!this.parsed) {\n      return false;\n    }\n\n    const date = new Date();\n    return date.getTime() <= this.parsed.exp;\n  }\n\n  public guard(scope?: string | string[]): boolean {\n    if (!this.parsed) {\n      return false;\n    }\n\n    if (typeof scope === 'undefined') {\n      return true;\n    }\n\n    const scopes = Array.isArray(scope) ? scope : [scope];\n    const filtered = scopes.filter((item: string) => !this.parsed.scopes.includes(item));\n    return filtered.length <= 0;\n  }\n\n  public async loadToken(options?: CookieGetOptions): Promise<boolean> {\n    const token = await this.get(options);\n\n    if (!token || typeof token !== 'string') {\n      return false;\n    }\n\n    this.parseToken(token);\n\n    if (this.isExpired()) {\n      this.remove();\n      return false;\n    }\n\n    return true;\n  }\n}\n"],"names":["Base","constructor","storage","this","prefix","get","options","getName","remove","set","value","setConfig","defaultConfig","config","name","super","generate","challenge","uuidv4","replaceAll","md","forge","sha256","create","update","hash","util","encode64","digest","data","replace","Promise","resolve","state","getConfig","key","authorize","scope","window","Error","all","then","client_id","authenticateUri","params","redirect_uri","getRedirectUri","response_type","code_challenge","code_challenge_method","searchParams","URLSearchParams","location","href","toString","getRequestTokenData","code","localState","tokenUri","uri","code_verifier","grant_type","getRefreshTokenData","token","refresh_token","redirectUri","protocol","hostname","port","rUri","instance","path","_options","setItem","getItem","removeItem","parseToken","parsed","jwt_decode","getParsed","isLoaded","isExpired","Date","getTime","exp","guard","Array","isArray","filter","item","scopes","includes","length","loadToken"],"mappings":"0OAO8BA,EAO5BC,YACYC,GAAAC,aAAAD,EAPFC,mBAA6B,CACrCC,OAAQ,UAYHC,IAAcC,GACnB,OAAOH,KAAKD,QAAQG,IAAOF,KAAKI,UAAWD,GAGtCE,OAAOF,GACZH,KAAKD,QAAQM,OAAOL,KAAKI,UAAWD,GAG/BG,IAAOC,EAAUJ,GACtB,OAAOH,KAAKD,QAAQO,IAAON,KAAKI,UAAWG,EAAOJ,GAG7CK,UAAUC,EAA4BC,GAEzCV,KAAKU,OADHA,EACY,IAAKD,KAAkBC,GAGzB,IAAKD,GAGdL,UACL,MAAMH,OAAEA,EAAMU,KAAEA,GAASX,KAAKU,OAE9B,OAAKT,EAIE,GAAGA,IAASU,IAHVA,kDCpC0Bd,EAMrCC,YAAsBC,EAA2BW,GAC/CE,MAAMb,GADcC,aAAAD,EALfC,mBAA6B,CAClCC,OAAQ,SACRU,KAAM,aAMNX,KAAKQ,UAAUR,KAAKS,cAAeC,GAG9BG,WACL,IAAIC,EAAY,GAAIC,SAAuBA,SAAuBA,SAClED,EAAYA,EAAUE,WAAW,IAAK,IAEtC,MAAMC,EAAKC,UAAMD,GAAGE,OAAOC,SAC3BH,EAAGI,OAAOP,GAEV,MAEMQ,EAFOJ,UAAMK,KAAKC,SAASP,EAAGQ,SAASC,MAE3BV,WAAW,IAAK,KAC/BA,WAAW,IAAK,KAChBW,QAAQ,KAAM,IAIjB,OAFA3B,KAAKM,IAAIQ,GAEFc,QAAQC,QAAQP,0BC1BzBxB,YAAoBY,EACAI,EACAgB,GAFA9B,YAAAU,EACAV,eAAAc,EACAd,WAAA8B,EAGbC,UAAUC,GACf,OAAIA,EACKhC,KAAKU,OAAOsB,GAGdhC,KAAKU,OAGPuB,UAAUC,GACf,IAAKC,OACH,MAAM,IAAIC,MAAM,8CAElB,MAAMN,EAAQf,OAASC,WAAW,IAAK,IAEvCY,QAAQS,IAAI,CACVrC,KAAKc,UAAUD,WACfb,KAAK8B,MAAMxB,IAAIwB,KAASQ,MAAK,EAAExB,MAC/B,MAAMyB,UAAEA,EAASC,gBAAEA,GAAoBxC,KAAKU,OAEtC+B,EAAS,CACbX,MAAAA,EACAS,UAAAA,EACAL,MAAAA,EACAQ,aAAc1C,KAAK2C,iBACnBC,cAAe,OACfC,eAAgB/B,EAChBgC,sBAAuB,QAGnBC,EAAe,IAAIC,gBAAgBP,GACzCN,OAAOc,SAASC,KAAO,GAAGV,KAA6BO,EAAaI,gBAIjEC,0BAA0BtB,EAAeuB,GAC9C,MAAMC,QAAmBtD,KAAK8B,MAAM5B,MAC9BY,QAAkBd,KAAKc,UAAUZ,MAEvC,GAAIoD,IAAexB,EACjB,MAAM,IAAIM,MAAM,sBAGlB,MAAMG,UAAEA,EAASgB,SAAEA,GAAavD,KAAKU,OAErC,MAAO,CACL8C,IAAKD,EACL7B,KAAM,CACJ2B,KAAAA,EACAd,UAAAA,EACAkB,cAAe3C,EACf4B,aAAc1C,KAAK2C,iBACnBe,WAAY,uBAKXC,oBAAoBzB,EAAe0B,GACxC,MAAMrB,UAAEA,EAASgB,SAAEA,GAAavD,KAAKU,OACrC,MAAO,CACL8C,IAAKD,EACL7B,KAAM,CACJa,UAAAA,EACAL,MAAAA,EACA2B,cAAeD,EACfF,WAAY,kBAKVf,iBACN,MAAMmB,YAAEA,GAAgB9D,KAAKU,QACrBuC,UAAUc,SAAEA,EAAQC,SAAEA,EAAQC,KAAEA,IAAW9B,OACnD,IAAI+B,EAAO,GAAGH,OAAcC,IAAWF,IAKvC,OAJkB,WAAbC,GAAkC,QAATE,GAAiC,UAAbF,GAAiC,OAATE,KACxEC,EAAO,GAAGH,MAAaC,KAAYC,IAAOH,KAGrCI,kCCjFTpE,YAAoBqE,GAAAnE,cAAAmE,EAGb7D,IAAcK,EAAcJ,EAAUJ,GAG3C,OAFAH,KAAKmE,SAAS7D,IAAIK,EAAMJ,EAAO,CAAE6D,KAAM,OAAQjE,IAExCyB,QAAQC,QAAWtB,GAGrBL,UAAoBS,EAAcR,GACvC,OAAOyB,QAAQC,QAAQ7B,KAAKmE,SAASjE,IAAIS,EAAMR,IAG1CE,aAAaM,EAAcR,SAC1BH,KAAKmE,SAAS9D,OAAOM,EAAM,CAAEyD,KAAM,OAAQjE,yCCnBXN,EAMxCC,YAAsBC,EAA2BW,GAC/CE,MAAMb,GADcC,aAAAD,EALfC,mBAA6B,CAClCC,OAAQ,SACRU,KAAM,iBAMNX,KAAKQ,UAAUR,KAAKS,cAAeC,iCCTJb,EAMjCC,YAAsBC,EAA2BW,GAC/CE,MAAMb,GADcC,aAAAD,EALfC,mBAA6B,CAClCC,OAAQ,SACRU,KAAM,SAMNX,KAAKQ,UAAUR,KAAKS,cAAeC,sCCJrCZ,YAAoBqE,GAAAnE,cAAAmE,EAIb7D,IAAcK,EAAcJ,EAAU8D,GAC3C,OAAOrE,KAAKmE,SAASG,QAAW3D,EAAMJ,GAKjCL,UAAoBS,EAAc0D,GAEvC,aAAarE,KAAKmE,SAASI,QAAW5D,GAGjCN,aAAaM,SACZX,KAAKmE,SAASK,WAAW7D,iCChBAd,EAQjCC,YAAsBC,EAA2BW,GAC/CE,MAAMb,GADcC,aAAAD,EAPfC,mBAA6B,CAClCC,OAAQ,SACRU,KAAM,SAQNX,KAAKQ,UAAUR,KAAKS,cAAeC,GAG9BJ,IAAcC,EAAUJ,GAI7B,MAHqB,iBAAVI,GACTP,KAAKyE,WAAWlE,GAEXP,KAAKD,QAAQO,IAAON,KAAKI,UAAWG,EAAOJ,GAG5CsE,WAAWb,GACjB5D,KAAK0E,OAASC,UAAWf,GAGpBgB,YACL,OAAO5E,KAAK0E,OAGPG,WACL,QAAS7E,KAAK0E,OAGTI,YACL,IAAK9E,KAAK0E,OACR,OAAO,EAIT,OADa,IAAIK,MACLC,WAAahF,KAAK0E,OAAOO,IAGhCC,MAAMhD,GACX,IAAKlC,KAAK0E,OACR,OAAO,EAGT,QAAqB,IAAVxC,EACT,OAAO,EAKT,OAFeiD,MAAMC,QAAQlD,GAASA,EAAQ,CAACA,IACvBmD,QAAQC,IAAkBtF,KAAK0E,OAAOa,OAAOC,SAASF,KAC9DG,QAAU,EAGrBC,gBAAgBvF,GACrB,MAAMyD,QAAc5D,KAAKE,IAAIC,GAE7B,SAAKyD,GAA0B,iBAAVA,KAIrB5D,KAAKyE,WAAWb,IAEZ5D,KAAK8E,cACP9E,KAAKK,UACE"}