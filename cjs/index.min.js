"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("node-forge"),t=require("uuid"),s=require("jwt-decode");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=i(e),n=i(s);class a{constructor(e){this.storage=e,this.defaultConfig={prefix:"oauth_"}}get(e){return this.storage.get(this.getName(),e)}remove(e){this.storage.remove(this.getName(),e)}set(e,t){this.storage.set(this.getName(),e,t)}setConfig(e,t){this.config=t?{...e,...t}:{...e}}getName(){const{prefix:e,name:t}=this.config;return e?`${e}${t}`:t}}exports.Base=a,exports.Challenge=class extends a{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"challenge"},this.setConfig(this.defaultConfig,t)}},exports.Client=class{constructor(e,t,s){this.config=e,this.challenge=t,this.state=s}getConfig(e){return e?this.config[e]:this.config}authorize(e){if(!window)throw new Error("Oauth service can only be run client side.");const s=this.getChallenge(),i=t.v4().replaceAll("-","");this.state.set(i);const{client_id:r,authenticateUri:n}=this.config,a={state:i,client_id:r,scope:e,redirect_uri:this.getRedirectUri(),response_type:"code",code_challenge:s,code_challenge_method:"S256"},o=new URLSearchParams(a);window.location.href=`${n}?${o.toString()}`}getChallenge(){let e=`${t.v4()}${t.v4()}${t.v4()}`;e=e.replaceAll("-","");const s=r.default.md.sha256.create();s.update(e);const i=r.default.util.encode64(s.digest().data).replaceAll("+","-").replaceAll("/","_").replace(/=$/,"");return this.challenge.set(e),i}async getRequestTokenData(e,t){const s=await this.state.get(),i=await this.challenge.get();if(s!==e)throw new Error("State do not match");const{client_id:r,tokenUri:n}=this.config;return{uri:n,data:{code:t,client_id:r,code_verifier:i,redirect_uri:this.getRedirectUri(),grant_type:"authorization_code"}}}getRefreshTokenData(e,t){const{client_id:s,tokenUri:i}=this.config;return{uri:i,data:{client_id:s,scope:e,refresh_token:t,grant_type:"refresh_token"}}}getRedirectUri(){const{redirectUri:e}=this.config,{location:{protocol:t,hostname:s,port:i}}=window;let r=`${t}://${s}${e}`;return("https:"===t&&"443"!==i||"http:"===t&&"80"!==i)&&(r=`${t}//${s}:${i}${e}`),r}},exports.CookieUniversal=class{constructor(e){this.instance=e}set(e,t,s){this.instance.set(e,t,{path:"/",...s})}async get(e,t){return Promise.resolve(this.instance.get(e,t))}async remove(e,t){await this.instance.remove(e,{path:"/",...t})}},exports.RefreshToken=class extends a{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"refresh_token"},this.setConfig(this.defaultConfig,t)}},exports.State=class extends a{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"state"},this.setConfig(this.defaultConfig,t)}},exports.StorageLocalForage=class{constructor(e){this.instance=e}set(e,t,s){this.instance.setItem(e,t)}async get(e,t){return await this.instance.getItem(e)}async remove(e){await this.instance.removeItem(e)}},exports.Token=class extends a{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"token"},this.setConfig(this.defaultConfig,t)}set(e,t){this.storage.set(this.getName(),e,t),this.parseToken(e)}parseToken(e){this.parsed=n.default(e)}getParsed(){return this.parsed}isLoaded(){return!!this.parsed}isExpired(){if(!this.parsed)return!1;return(new Date).getTime()<=this.parsed.exp}guard(e){if(!this.parsed)return!1;if(void 0===e)return!0;return(Array.isArray(e)?e:[e]).filter((e=>!this.parsed.scopes.includes(e))).length<=0}async loadToken(e){const t=await this.get(e);return!!t&&(this.parseToken(t),!this.isExpired()||(this.remove(),!1))}};
//# sourceMappingURL=index.min.js.map
