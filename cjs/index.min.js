"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("node-forge"),t=require("uuid"),s=require("jwt-decode");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var i=r(e),n=r(s);class o{constructor(e){this.storage=e,this.defaultConfig={prefix:"oauth_"}}get(e){return this.storage.get(this.getName(),e)}remove(e){this.storage.remove(this.getName(),e)}set(e,t){return this.storage.set(this.getName(),e,t)}setConfig(e,t){this.config=t?{...e,...t}:{...e}}getName(){const{prefix:e,name:t}=this.config;return e?`${e}${t}`:t}}class a extends o{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"challenge"},this.setConfig(this.defaultConfig,t)}generate(){let e=`${t.v4()}${t.v4()}${t.v4()}`;e=e.replaceAll("-","");const s=i.default.md.sha256.create();s.update(e);const r=i.default.util.encode64(s.digest().data).replaceAll("+","-").replaceAll("/","_").replace(/=$/,"");return this.set(e),Promise.resolve(r)}}class h{constructor(e,t,s){this.config=e,this.challenge=t,this.state=s}getConfig(e){return e?this.config[e]:this.config}authorize(e){if(!window)throw new Error("Oauth service can only be run client side.");const s=t.v4().replaceAll("-","");Promise.all([this.challenge.generate(),this.state.set(s)]).then((([t])=>{const{client_id:r,authenticateUri:i}=this.config,n={state:s,client_id:r,scope:e,redirect_uri:this.getRedirectUri(),response_type:"code",code_challenge:t,code_challenge_method:"S256"},o=new URLSearchParams(n);window.location.href=`${i}?${o.toString()}`}))}async getRequestTokenData(e,t){const s=await this.state.get(),r=await this.challenge.get();if(s!==e)throw new Error("State do not match");const{client_id:i,tokenUri:n}=this.config;return{uri:n,data:{code:t,client_id:i,code_verifier:r,redirect_uri:this.getRedirectUri(),grant_type:"authorization_code"}}}getRefreshTokenData(e,t){const{client_id:s,tokenUri:r,refreshUri:i}=this.config;return{uri:i||r,data:{client_id:s,scope:e,refresh_token:t,grant_type:"refresh_token"}}}getRedirectUri(){const{redirectUri:e}=this.config,{location:{protocol:t,hostname:s,port:r}}=window;let i=`${t}://${s}${e}`;return("https:"===t&&"443"!==r||"http:"===t&&"80"!==r)&&(i=`${t}//${s}:${r}${e}`),i}}class c extends o{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"refresh_token"},this.setConfig(this.defaultConfig,t)}}class l extends o{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"state"},this.setConfig(this.defaultConfig,t)}}class u extends o{constructor(e,t){super(e),this.storage=e,this.defaultConfig={prefix:"oauth_",name:"token"},this.setConfig(this.defaultConfig,t)}set(e,t){return"string"==typeof e&&this.parseToken(e),this.storage.set(this.getName(),e,t)}parseToken(e){this.parsed=n.default(e)}getParsed(){return this.parsed}isLoaded(){return!!this.parsed}isExpired(){if(!this.parsed)return!1;return(new Date).getTime()<=this.parsed.exp}guard(e){if(!this.parsed)return!1;if(void 0===e)return!0;return(Array.isArray(e)?e:[e]).filter((e=>!this.parsed.scopes.includes(e))).length<=0}async loadToken(e){const t=await this.get(e);return!(!t||"string"!=typeof t)&&(this.parseToken(t),!this.isExpired()||(this.remove(),!1))}}exports.Base=o,exports.Challenge=a,exports.Client=h,exports.CookieUniversal=class{constructor(e){this.instance=e}set(e,t,s){return this.instance.set(e,t,{path:"/",...s}),Promise.resolve(t)}async get(e,t){return Promise.resolve(this.instance.get(e,t))}async remove(e,t){await this.instance.remove(e,{path:"/",...t})}},exports.Init=class{constructor(e,t,s){var r,i,n,o;this.oAuthConfig=e,this.storage=t,this.options=s,this.token=new u((null===(r=null==s?void 0:s.token)||void 0===r?void 0:r.storage)||t,null==s?void 0:s.token),this.refreshToken=new c((null===(i=null==s?void 0:s.refreshToken)||void 0===i?void 0:i.storage)||t,null==s?void 0:s.refreshToken),this.challenge=new a((null===(n=null==s?void 0:s.challenge)||void 0===n?void 0:n.storage)||t,null==s?void 0:s.challenge),this.state=new l((null===(o=null==s?void 0:s.state)||void 0===o?void 0:o.storage)||t,null==s?void 0:s.state),this.client=new h(this.oAuthConfig,this.challenge,this.state)}getToken(){return this.token}getRefreshToken(){return this.refreshToken}getChallenge(){return this.challenge}getState(){return this.state}getClient(){return this.client}},exports.RefreshToken=c,exports.State=l,exports.StorageLocalForage=class{constructor(e){this.instance=e}set(e,t,s){return this.instance.setItem(e,t)}async get(e,t){return await this.instance.getItem(e)}async remove(e){await this.instance.removeItem(e)}},exports.Token=u;
//# sourceMappingURL=index.min.js.map
